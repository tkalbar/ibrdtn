% -----------------------------------------------
%   The Breadcrumb Router
% -----------------------------------------------
\subsection{The Breadcrumb Router}

The {\sc Breadcrumb} Router is designed to perform geo-source routing by making use of the {\sc GeoRouting} extension block attached to a bundle, the GPS coordinates of the host, and the GPS coordinates of neighboring peers. As described in the {\sc GeoRouting} section, the {\sc GeoRouting} block contains a list of entries which specify routing goals (specific nodes or GPS locations). For each bundle, the router takes the entry at the end of the list, and compares it against GPS coordinates of neighboring peers to decide if a peer should receive the bundle. The router also periodically compares this entry to the GPS coordinates of the host to decide if the entry should be popped from the list (since the bundle has now visited that location). Using this strategy the bundle eventually visits every location in the GeoRouting block. Since following these entries back to a particular location is analogous to following breadcrumbs, we have coined our router, the Breadcrumb Router.

In IBR-DTN, routers loop through a task queue in order to perform their tasks. As such, the {\sc Breadcrumb} Router's functionality can be separated into three tasks:

\begin{description}
\item[SearchNextBundle] Whenever the router receives an event indicating that data has changed regarding it's connection to a peer (for example, a successful handshake with a newly discovered peer or a completed bundle transfer), the router computes the set of bundles to send to the peer.
\item[NextExchange] The router needs GPS location information from all neighboring peers in order to guide routing decisions. This task, which is queued periodically, triggers this exchange.
\item[UpdateMyLocation] The router needs to maintain the location of the host in order to know when a {\sc GeoRouting} entry has been visited. This task is queued both periodically, and whenever a bundle is received to determine which entries to remove for each bundle.
\end{description}

\subsubsection{Bundle Filters and Meta Bundles}

The SearchNextBundle and UpdateMyLocation tasks both require inspecting the location information packaged in the GeoRouting block of each bundle. Performing the inspection efficiently using IBR-DTN presents a dilemma. Pulling each bundle, inspecting it, and potentially modifying it is inherently inefficient since the bundles are in persistent storage. On the otherhand, maintaining a data-structure in memory that contains all the Geo information pertaining to each bundle goes against the design of IBR-DTN. We devised an efficient solution that does not require the creation of an additional data-structure and minimizes the amount of bundles that need to pulled from persistent storage.

This solution uses two IBR-DTN constructs: {\sc bundle filters} and {\sc meta bundles}. {\sc Meta bundles} are light-weight representations of bundles that contain fields of particular interest. A meta bundle is generated for each bundle. {\sc Bundle filters} query the storage for a list of meta bundles that meet a set of rules. For our implementation we added three fields to each {\sc meta bundle}:

\begin{description}
\item[hasgeoroute] A boolean identifier indicating that the bundle has a {\sc GeoRouting} block
\item[nextgeohop] The last entry in the {\sc GeoRouting} block
\item[reacheddest] A boolean flag indicating that there are no more entries in the {\sc GeoRouting} block (i.e., the bundle has reached its ``final'' destination)
\end{description}

We also created two {\sc bundle filters}, one pertaining to each task that needs to inspect the bundles.

\begin{description}
\item[SearchNext] This filter is used to determine what bundles to send to each peer, so it is called in the {\sc SearchNextBundle} task. For each {\sc meta bundle} that {\sc hasgeoroute} is {\sc true}, the filter compares the location of the peer with the {\sc nextgeohop} to see if the peer is closer to it than the host. If so, the meta bundle is added to the list.
\item[UpdateLocation] This filter is used to determine which bundles need to have their {\sc GeoRouting} block entries updated, since the location in the last entry has been visited. It uses similar logic to the {\sc SearchNext} filter, but instead compares the location of the host to the {\sc nextgeohop} from the meta bundle. If the location of the host falls within a prespecified margin of the {\sc nextgeohop} location, the meta bundle is added to the list.
\end{description}

The key benefit of using the {\sc bundle filters} is that only one lookup into persistent storage is necessary to retrieve a list of meta bundles that need action. In the case of the {\sc SearchNextBundle} task, the list return by the corresponding filter is simply used to transfer bundles. In the {\sc UpdateMyLocation} task, each meta bundle in the list represents a bundle that needs to be pulled from storage to have its {\sc GeoRouting} block modified. However, since we added that {\sc nextgeohop} entry to each meta bundle for filtering purposes, we are guaranteed that each bundle that is pulled from storage actually needs the last entry in its {\sc GeoRouting} block to be popped off. For example, imagine that there are 10 bundles in storage, and the current location of the host satisfies the {\sc GeoRouting} block entry for one of these bundles. Our solution requires only two lookups into storage: one to retrieve the list of meta bundles that need modification (one in this case) and one to replace that bundle in storage. This is a considerable improvement over having to retrieve each bundle from storage just to inspect a {\sc GeoRouting} block that in the vast majority of cases will not need any updates.

\subsubsection{Additional Features}
Although the primary functionality of the router is geo-source routing, it also doubles as an epidemic router for all bundles that do not contain {\sc GeoRouting} blocks. This functionality was useful so that we could use a single router to both build our trajectories (lay the breadcrumbs) and to follow them back to the source (follow the breadcrumbs). The router also supports single-copy routing, so that for tracking purposes during testing, only a single bundle with a {\sc GeoRouting} block persists in the network.

\subsubsection{Future Improvements}
For our initial prototype, we focused on ordered, geo-source routing. Therefore, our router assumes that all {\sc GeoRouting} blocks contain entries that must be visited in order, and that each entry pertains to a particular GPS location. However, our {\sc GeoTracking} and {\sc GeoRouting} blocks also support unordered and hop entries. Supporting a hetereogenous series of entries would make the router more generalizable since it could be applied to scenarios where the order that locations are visited does not matter, or where a few specific nodes must be visited.

Although not specifically associated with our router, current IBR-DTN does not support updates to bundles in storage. Therefore, each update to a {\sc GeoRouting} block requires a separate remove and store operation. This is inefficient because it requires that the entire bundle be re-written to storage during every update (this actually makes our modifications to the meta bundles even more critical). Adding this update functionality would improve the performance of our router and of IBR-DTN storage in general.

